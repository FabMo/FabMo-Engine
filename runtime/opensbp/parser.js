/*
 * runtime/opensbp/parser.js
 *
 * This is the wrapper module for the OpenSBP parser.
 * Largely, parsing is done by sbp_parser.js which is generated by peg.js from sbp_parser.pegjs
 * NOTE - if you change the grammar, you must re-generate sbp_parser.js by running pegjs sbp_parser.pegjs
 *       and then re-run the tests to make sure everything still works.
 *
 * NOTE 1/11/24 PEGJS is dead (used PEGJS v0.7.0). It is being replaced by PEGGYJS.
 * ~9/25/24 Changed to PEGGY.js v4.0.3; Installed globally using npm install -g peggy@4.0.3
 *
 * Run the parser generator using:         peggy -o sbp_parser.js sbp_parser.pegjs
 *   ... test varioius definitions with:   node ./test_parser.js
 *
 * This module wraps the parsing functions with convenience methods and objects and provides some additional
 * parsing functionality (sanitizing inputs, optimized parsing for certain commands, working with streams, etc)
 */

var fs = require("fs");
var stream = require("stream");
var util = require("util");

var sbp_parser = require("./sbp_parser");
var log = require("../../log").logger("sbp");
var CMD_SPACE_RE = /(\w\w)([ \t]+)([^\s\t,].*)/i;
var CMD_RE = /^\s*(\w\w)(((\s*,\s*)([+-]?[0-9]+(\.[0-9]+)?)?)+)\s*$/i;
var STUPID_STRING_RE = /(&[A-Za-z]\w*)\s*=([^\n]*)/i;

// Parse the provided statement
// Return the parsed statement
// fastParse attempts to use string slicing and regular expressions to parse the simpler mnemonic commands
// if fastParse can't figure it out (command contains complex expressions or is not of the right type)
// it will return null.  Since the majority of all OpenSBP commands are simple ones, this function will
// usually work, and will save a bunch of time over using the pegjs parser for everything.
//   statement - The string statement to parse
function fastParse(statement) {
    var match = statement.match(CMD_RE);
    if (match) {
        // 2 character mnemonic commands (IF is an exception)
        if (match[1] === "IF") {
            return null;
        }
        // Return value, which we'll fill in with arguments
        var retval = {
            type: "cmd",
            cmd: match[1],
            args: [],
        };
        // Parse the arguments, build a list as we go
        var args = match[2].split(",");
        var pargs = args.slice(1);
        for (var i = 0; i < pargs.length; i++) {
            var arg = pargs[i];
            if (arg.trim() === "") {
                retval.args.push(undefined);
            } else {
                // TODO not sure we actually need to do this - numbers get parsed out later also
                var n = Number(arg);
                retval.args.push(isNaN(n) ? arg : n);
            }
        }
        // Return the return value
        return retval;
    }

    match = statement.match(CMD_SPACE_RE);
    if (match) {
        if (match[1] != "IF") {
            statement = statement.replace(
                CMD_SPACE_RE,
                // eslint-disable-next-line no-unused-vars
                function (match, cmd, space, rest, offset, string) {
                    return cmd + "," + rest;
                }
            );
        }
    }
    return null;
}

// Parse the provided line
// Returns an object representing the parsed statement
// Tries to fast parse first, falls back on the more thorough pegjs parser
// TODO:? *FastParse is NOT CURRENTLY HANDLING absence of comma in first position, or decimal numbers without leading 0
function parseLine(line) {
    line = line.replace(/\r/g, "");
    //Check for metadata
    if (line.includes("!FABMO!")) {
        return { type: "metadata" };
    }
    // Extract end-of-line comments
    var parts = line.split("'");
    var statement = parts[0];
    var comment = parts.slice(1, parts.length);

    try {
        // Use parse optimization
        var obj = fastParse(statement);
        // But fall back on PegJS
        if (!obj) {
            obj = sbp_parser.parse(statement);
        }
    } catch (e) {
        // Parse failure could be because of a stupid unquoted string:
        // eg: &mystring = Hey this is a string, no big deal.
        // If this is a case, actually allow it like an insane person:
        var match = statement.match(STUPID_STRING_RE);
        if (match) {
            obj = { type: "assign", var: match[1], expr: match[2] };
        } else {
            if (e instanceof sbp_parser.SyntaxError) {
                const normalizedError = normalizePeggyError(e);
                throw normalizedError; // Re-throw the normalized error
            } else {
                throw e; // Re-throw other exceptions
            }
            // Now you can use normalizedError.offset, normalizedError.line, etc.
            //throw e; // Or if not, throw the exception like we should do anyway
            //const normalizedError = normalizePeggyError(e);
            ////throw new Error(normalizedError);
            //throw normalizedError;
            //////* handleError(normalizedError);
        }
    }

    // Deal with an OpenSBP command inside the THEN of an IF/THEN statement, passed back
    // ... inside an object with a type of "cond" and a statement block
    if (obj.type === "cond" && obj.stmt.type === "cmd") {
        obj = {
            // convert the object into a cmd type object with a statement block
            type: "cmd",
            cmd: obj.stmt.cmd,
            args: obj.stmt.args,
            block: obj.block,
        };
    }

    // Deal with full-line comments
    if (Array.isArray(obj) || obj === null) {
        obj = { type: "comment", comment: comment };
    } else {
        if (comment != "") {
            obj.comment = comment;
        }
    }
    if (obj.type == "cmd") {
        obj.cmd = obj.cmd.toUpperCase();
    }

    return obj;
}

function normalizePeggyError(err) {
    if (err instanceof sbp_parser.SyntaxError) {
        // Extract properties from the new error object
        err.offset = err.location.start.offset;
        err.line = err.location.start.line;
        err.column = err.location.start.column;
        err.expected = err.expected || [];
        err.found = err.found || null;
        err.message = err.message || sbp_parser.SyntaxError.buildMessage(err.expected, err.found);
        err.name = "SyntaxError";
        return err;
    }
    // If it's not a SyntaxError, rethrow it
    throw err;
}

// Parse a string or array of strings
// Returns a list of parsed statements
//   data - The string or array input to parse
function parse(data) {
    var output = [];
    var lines = Array.isArray(data) ? data : data.split("\n");

    for (var i = 0; i < lines.length; i++) {
        try {
            output.push(parseLine(lines[i]));
        } catch (err) {
            if (err.name === "SyntaxError") {
                log.error("Syntax Error on line " + (i + 1));
                err.line = i + 1; // Update line number if necessary
                log.error("(LINE-" + err.line + ") " + err.message);
            } else {
                log.error(err);
            }
            throw err; // Rethrow the error after logging
        }
    }
    return output;
}
// function parse(data) {
//     var output = [];
//     // Parse from a string or an array of strings
//     if (Array.isArray(data)) {
//         var lines = data;
//     } else {
//         lines = data.split("\n");
//     }

//     // Iterate over lines and parse one by one.  Throw an error if any don't parse.
//     for (var i = 0; i < lines.length; i++) {
//         try {
//             output.push(parseLine(lines[i]));
//         } catch (err) {
//             if (err.name == "SyntaxError") {
//                 log.error("Syntax Error on line " + (i + 1));
//                 err.line = i + 1;
//                 log.error(
//                     "(LINE-" + err.line + ") Expected " + JSON.stringify(err.expected) + " but found " + err.found
//                 );
//                 log.error(err.line);
//             } else {
//                 log.error(err);
//             }
//             throw err;
//         }
//     }
//     return output;
// }

// Constructor for Parser object
// Parser is a transform stream that accepts string input and streams out parsed statement objects
function Parser(options) {
    options = options || {};
    options.objectMode = true;

    // allow use without new
    if (!(this instanceof Parser)) {
        return new Parser(options);
    }
    this.scrap = "";
    // init Transform
    stream.Transform.call(this, options);
}
util.inherits(Parser, stream.Transform);

// Transform function, processes chunks of string data coming in, pushing parsed objects to the output
Parser.prototype._transform = function (chunk, enc, cb) {
    var str = this.scrap + chunk.toString();
    this.pause();
    try {
        var start = 0;
        for (var i = 0; i < str.length; i++) {
            if (str[i] === "\n") {
                var substr = str.substring(start, i);
                let parsedline = parseLine(substr);
                // Skip entries that are metadata
                if (parsedline.type != "metadata") {
                    this.push(parsedline);
                }
                start = i + 1;
            }
        }
        this.scrap = str.substring(start);
    } catch (e) {
        this.emit("error", e); // Emit the error to be handled by the consumer of the stream
    }
    this.resume();
    cb();
};
//Parser.prototype._transform = function (chunk, enc, cb) {
//     var str = this.scrap + chunk.toString();
//     this.pause();
//     try {
//         var start = 0;
//         for (var i = 0; i < str.length; i++) {
//             if (str[i] === "\n") {
//                 var substr = str.substring(start, i);
//                 let parsedline = parseLine(substr);
//                 //Skip entries that are metadata (Used to prune header metadata on macros)
//                 if (parsedline.type != "metadata") {
//                     this.push(parsedline);
//                 }
//                 start = i + 1;
//             }
//         }
//         this.scrap = str.substring(start);
//     } catch (e) {
//         log.error(e);
//     }
//     this.resume();
//     cb();
// };

// Handle a stream flush
Parser.prototype._flush = function (done) {
    if (this.scrap) {
        this.push(parseLine(this.scrap));
    }
    this.scrap = "";
    done();
};

// Parse data from the provided stream
// Return a stream whose output is a stream of parsed statements
//         s - The input stream
//   options - parser options
function parseStream(s, options) {
    var parser = new Parser(options);
    return s.pipe(parser);
}

// Parse the specified file
//   filename - Full path of file to be parsed
//   callback - Called with parsed data, or with error if error
function parseFile(filename, callback) {
    var st = fs.createReadStream(filename);
    var obj = [];
    return parseStream(st)
        .on("data", function (data) {
            obj.push(data);
        })
        .on("end", function () {
            callback(null, obj);
        })
        .on("error", function (err) {
            callback(err);
        });
}

// Below here are some functions for testing the parser functions
//   -use: node parser.js filename.sbp
// --------------------------------------------------------------

// eslint-disable-next-line no-unused-vars
var main = function () {
    var argv = require("minimist")(process.argv);
    var filename = argv["_"][2];

    if (filename) {
        log.tick();
        fs.readFile(filename, "utf8", function (err, data) {
            if (err) {
                return log.error(err);
            }

            // eslint-disable-next-line no-unused-vars
            var obj = parse(data);
            log.tock("parse");
        });
    } else {
        log.debug("Usage: node parser.js filename.sbp");
    }
};

var main2 = function () {
    var argv = require("minimist")(process.argv);
    var fs = require("fs");
    var filename = argv["_"][2];
    if (filename) {
        log.tick();
        var fileStream = fs.createReadStream(filename);
        var obj = [];
        parseStream(fileStream)
            .on("data", function (data) {
                obj.push(data);
            })
            .on("end", function () {
                log.debug(obj.length + " lines processed.");
                log.tock("parse");
            });
    }
};

if (require.main === module) {
    // main();
    main2();
}

exports.parse = parse;
exports.parseFile = parseFile;
exports.parseStream = parseStream;
