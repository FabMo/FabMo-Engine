#!/usr/bin/perl -w

sub logmsg {
    $arg = shift;
    system("/usr/bin/logger \"$arg\"");
}
logmsg("collect_and_export_data_to_usb_drive launched");
sleep(2);

logmsg("collect_and_export_data_to_usb_drive entering collection");

if (scalar(@ARGV) < 1) {
    print(STDERR "ERROR:\tmissing parameter\n\tUsage: $0 {path to usb disk}\n\n");
    exit(-1);
}
my $USB_DRIVE_PATH = $ARGV[0];

### https://www.perltutorial.org/

#### This program is meant to be extensible
#### This program will be invoked once when a usb drive in inserted
#### This program will receive mount point of the first USB disk
#### as a parameter. If any function needs to look beyond the first
#### USB drive, then it will have to find any other disks it is
#### interested in.

#### Current approach to how this works. There is a dictionary/hash/map
#### of files that can appear on the usb disk where the "key" is the
#### name of the file that should appear on the usb drive to trigger
#### some action and the "value" is a reference to the function that
#### should be executed if that key is present.

## Data to drive what we do. ##########################################
my %work_index;
#            filename      = workfunction reference
$work_index{'network.txt'} = \&capture_network_info;
$work_index{'shopbotsupport.txt'} = \&capture_shopbotsupport_info;


## Work functions ##########################################

sub capture_network_info() {

	# parameter processing
	my $target_file = shift(@_); #grab the parameter:w
	my $path_to_file= shift(@_); #grab the path parameter
	my ($message,  $html_file) = collect_ifconfig();

	# file creation
	system("echo \'$message\' > \'$target_file\'");
	system("echo \'$html_file\' > \'$path_to_file/fabmo.html\'");
}

sub collect_ifconfig () {

	# gather info from system
	my $eth0 = `/sbin/ifconfig eth0 | /bin/grep "inet " | /bin/sed "s/inet/ip address/" | /usr/bin/cut -c 9-`;
	$eth0 =~ s/[^\d]*(\d+\.\d+\.\d+\.\d+).*/$1/;
	chomp($eth0); # $eth0 should now be a simple IP Address with no other text 
        my $network =  `/sbin/ifconfig`;  # this will be the full network config dump

	# Build messages
	my $message ="\\n\\n\\nYour ShopBot Tool's IP Address is: $eth0\\n" .
		     "\\n" .
	             "\\n\\n================ Full Network ================\\n"  .
	             "      Useful for tech support and debugging\\n\\n"  .
                     $network;

	my $html_file_contents =
		"<html> <body> <p> <br/> " .
		"<h1> Click on this link in your browser to access FabMo: " .
		"<a href=\"http://$eth0\"> FabMo </a> </h1>" .
		"or copy and paste this to your browser address bar: <b> http://$eth0 </b> </p>" .
		"<p> Once you have FabMo open on your tool, you will probably want to create a " .
		"bookmark in your browser to make returning to FabMo easier.  </p> </body> </html>";

	return($message, $html_file_contents);
}


sub capture_shopbotsupport_info() {
	my $target_file = shift(@_); #grab the full file path parameter
	my $path_to_file= shift(@_); #grab the path parameter

	# capture networking info to file
	my $message = collect_ifconfig();
	system("echo \"$message\" > /home/pi/ifconfig_out.txt");

	#capture df, top, ping, resolve.conf and status
	$message = "System Status:";
	$message .= "\n\n/bin/df /dev/mmcblk0p1\n";
	$message .= `/bin/df /dev/mmcblk0p1`;
	$message .= "\n\n/usr/bin/top -b -n1\n";
	$message .= `/usr/bin/top -b -n1`;
	$message .= "\n\n/bin/ping -c 3 8.8.8.8\n";
	$message .= `/bin/ping -c 3 8.8.8.8`;
	$message .= "\n\n/bin/cat /etc/resolv.conf\n";
	$message .= `/bin/cat /etc/resolv.conf`;
	$message .= "\n\n /usr/bin/sudo /bin/systemctl status fabmo\n";
	$message .= `/usr/bin/sudo /bin/systemctl status fabmo`;
	$message .= "\n\n /usr/bin/sudo systemctl status fabmo-updater\n";
	$message .= `/usr/bin/sudo systemctl status fabmo-updater`;

	# put results in a file
	system("cd /home/pi; echo \"$message\" > system_status.txt");
	print "message output done\n";

	#capture logs
	my $currentFabmoLogFileName = "`cd /opt/fabmo/log; /bin/ls -lt *.txt | /usr/bin/head -1 | /usr/bin/cut -c 43-`";
	system("/bin/cp /var/log/daemon.log /home/pi/daemon.log; /bin/cp /var/log/syslog /home/pi/syslog; /bin/cp \"/opt/fabmo/log/$currentFabmoLogFileName\" \"/home/pi/$currentFabmoLogFileName\"");
	system("cd /home/pi; /usr/bin/zip /home/pi/shopbotsupport.zip daemon.log syslog ifconfig_out.txt system_status.txt $currentFabmoLogFileName");

	# zip up files
	system("/bin/cp /home/pi/shopbotsupport.zip \"$path_to_file/shopbotsupport.zip\"");

	# cleanup
	system("cd /home/pi; /bin/rm daemon.log syslog shopbotsupport.zip ifconfig_out.txt system_status.txt $currentFabmoLogFileName");

	# tell the user where to look for zip file
	$message = "Your tech support info is recorded in shopbotsupport.zip on this device";
	system("echo \"$message\" > \"$target_file\"");
	logmsg("$message");
}

## pseudo main() that loops through the work_index and calls needed functions ##

## main()

## If we write to the usb drive, we will end by unmounting it; otherwise, we'll
## leave it alone. This flag helps manage that.
my $must_umount_flag = 0;

@files = sort(keys(%work_index));
for my $file (@files) {
    my $fullpath = "$USB_DRIVE_PATH/$file";
    logmsg("testing trigger: $fullpath");
    if (-e $fullpath) {
        logmsg("processing $fullpath");
        $work_index{$file}("$fullpath", "$USB_DRIVE_PATH");
	$must_umount_flag = 1;
    } else {
        logmsg("No trigger for: $fullpath");
    }
}
sleep(5);
if ($must_umount_flag) {
	system("/bin/umount \"$USB_DRIVE_PATH\"");
}

